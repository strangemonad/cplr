#!/usr/bin/env python

"""A harness for running CPLR related tasks.

Note, the compiler proper can be invoked directly via the top-level 'cplr'
command.

Usage:
   run verb [arguments...]

The run script does not take any flags.

The allowed verbs are:
clean      - Sanitize the sources.
cleanall      - Make the source tree squeaky clean.
gendoc     - Generate an updated version of the documentation.
help       - Display help information.
pack    - Bundle CPLR for distribution.
tests      - Run the CPLR test suite and print a summary.
testreport - Run the tests and generate a detailed test report.

Examples:
   run tests
   run help clean
   run submit a2

"""

import commands
import os
import re
import shutil
import sys
import unittest

import paths

import docutils.core

from util import asserts

import cplrdoc
import systemtest


# Module-private definitions:

_BUILD_DIR = os.path.join(".", "build")
_CPLR_TOOLCHAIN = os.path.join(".", "toolchain", "cplr")


def main(args):
   """Dispatch CPLR-related actions.
   
   Parameters:
      args - The action to be run along with parameters for that action.
   
   Results:
      0 on success and a POSIX error number indicating the error otherwise.
   
   Side effects:
      Whatever side effects are generated by the actions.

   """

   assert os.path.isdir("./src"), \
         "Must invoke from the root of the CPLR directory."
   
   action = None
          
   try:
      verb = args[0]
      params = args[1:]
      action = getFunction(verb)
   except (IndexError, AttributeError), e:
      help()
      return 2

   action(params)


# Actions.

def help(args=None):
   """Display help information.
   
   Help can be displayed for each of the available actions.

   """
   
   if args and len(args) == 1:
      param = args[0]
      print getFunction(param).__doc__
   else:
      print __doc__


def clean(args=None):
   """Sanitize the sources.
   
   In particular, clean removes all .pyc and .pyo files and removes all build 
   results.

   """

   os.path.isdir(_BUILD_DIR) and shutil.rmtree(_BUILD_DIR)
   os.path.isdir(_CPLR_TOOLCHAIN) and shutil.rmtree(_CPLR_TOOLCHAIN)

   unwanted = re.compile("(.DS_Store|.pyc|.pyo|^svn-commit.tmp)$")
   for root, dirs, files in os.walk("."):
      for f in files:
         if unwanted.search(f):
            os.remove(os.path.join(root, f))


   # The configure / automake stuff for the Boehm GC is a little stupid and
   # doesn't completely clean up after itself.
   
   # XXX this path info is duplicated.
   gcSrc = os.path.join(".", "toolchain", "src", "gc6.7")
   
   gcBuildCruft = [os.path.join(gcSrc, ".deps"),
                   os.path.join(gcSrc, "Makefile"),
                   os.path.join(gcSrc, "config.status"),
                   os.path.join(gcSrc, "libtool"),
                   os.path.join(gcSrc, "config.log"),
                   os.path.join(gcSrc, "doc", "Makefile"),
                   os.path.join(gcSrc, "include", "Makefile")]
   for item in gcBuildCruft:
      if not os.path.exists(item):
         continue

      if os.path.isdir(item):
         shutil.rmtree(item)
      else:
         os.remove(item)
   

def cleanall(args=None):
   """Make the source tree squeaky clean.
   
   This is a superset of the clean action. This will also remove pre-compiled 
   CPLR components like the lexer pickle.

   """
   
   clean(args)
   unwanted = re.compile("(.pkl)$")
   for root, dirs, files in os.walk("."):
      for f in files:
         if unwanted.search(f):
            os.remove(os.path.join(root, f))


def gendoc(args=None):
   """Generate an updated version of the documentation.
   
   """
   
   makeBuildDir()

   rstPath = os.path.join(_BUILD_DIR, "cplr.txt")
   texPath = os.path.join(_BUILD_DIR, "cplr.tex")
   stylePath = os.path.join(_BUILD_DIR, "Style.sty")
   
   cplrdoc.genRST(rstPath)
   shutil.copyfile(os.path.join("doc", "Style.sty"), stylePath)
   cmd = """toolchain/bin/rst2latex.py %s %s\
            --hyperlink-color=DarkBlue\
            --no-section-subtitles\
            --documentclass="book"\
            --documentoptions="11pt,letterpaper,openright"\
            --stylesheet-path="%s"\
         """ % (rstPath, texPath, stylePath)

   output = commands.getoutput(cmd)
   if output:
      print output


def pack(args=None):
   """Bundle CPLR for distribution.
   
   Packaging will do the following and stop if something went wrong at any 
   point.
      1) Produce a test report.
      2) Generate the documentation.
      3) Clean the source tree.
      4) Bundle the results in a tar ball.

   """

   # cleanAll(None)
   # 
   # # XXX change this to test report.
   # tests(None)
   # gendocs(None)

   clean(None)
   
   # Add stuff to the archive
   files = []
   unwanted = re.compile("(.svn|ignoreForPackage)")
   for root, dirs, moreFiles in os.walk("."):
      if unwanted.search(root):
         continue
      else:
         files.extend([os.path.join(root, f) for f in moreFiles])

   # Ignore HFS resource forks.
   os.putenv("COPY_EXTENDED_ATTRIBUTES_DISABLED", "true") # On 10.4
   os.putenv("COPYFILE_DISABLE", "true") # On 10.5

   # print "tar -cvf CPLR.tar %s" % " ".join(files)
   print commands.getoutput("tar -cvf CPLR.tar %s" % " ".join(files))
   print commands.getoutput("bzip2 CPLR.tar")


def tests(args=None, verbose=False):
   """Run the CPLR test suite and print a summary.
   
   """

   suite = unittest.TestSuite()

   srcPaths = [os.path.join(".", "src", "apps", "compiler"),
               os.path.join(".", "src", "lib")]
   testFilePattern = re.compile("^_test_.*\.py$")
   testLoader = unittest.defaultTestLoader

   for path in srcPaths:
      for root, dirs, files in os.walk(path):
         for f in files:
            if testFilePattern.search(f):
               # Completely uncosher path manipulation follows.
               # Viewer discretion is advised.
               testModule = os.path.join(root, os.path.splitext(f)[0])
               testModule = testModule.replace(path + os.sep, "")
               testModule = testModule.replace(os.sep, ".")

               suite.addTest(testLoader.loadTestsFromName(testModule))


   verbosity = verbose and 2 or 1
   print "Running unit tests:\n"
   unittest.TextTestRunner(verbosity=verbosity).run(suite)
   print "\n\n"
   
   print "Running system tests:\n"
   systemtest.runTests(verbosity=verbosity)


def testreport(args=None):
   """Run the tests and generate a detailed test report.
   
   """
   tests(verbose=True)


# Helper functions.

def getFunction(name):
   """Get a function object from this module by name.

   """

   thisModule = __import__(__name__)
   func = getattr(thisModule, name)
   assert callable(func)
   return func


def makeBuildDir():
   """Make the build directory if it doesn't already exist.

   """
   if not os.path.isdir(_BUILD_DIR):
      os.mkdir(_BUILD_DIR)


if __name__ == '__main__':
   main(sys.argv[1:])
